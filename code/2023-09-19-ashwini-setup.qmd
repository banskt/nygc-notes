---
title: Setup Ashwini
---

Running documentation for the server setup in Ashwini.
Here are some Linux references which I find useful:

  - [Linux from Scratch](https://www.linuxfromscratch.org/) main book -- 
  [Stable version](https://www.linuxfromscratch.org/lfs/view/stable/) | 
  [All releases](https://www.linuxfromscratch.org/lfs/view/). 
  There are many helpful installation notes in the subprojects, e.g.
  [BLFS or Beyond Linux from Scratch](https://www.linuxfromscratch.org/blfs/view/stable/). 

## Internet Connection

For overview see, [Configuring Networks](https://ubuntu.com/server/docs/network-configuration) on Ubuntu Server.

  - Check ethernet name:
  ```bash
  ip -d address
  ```
  - Create configuration in `/etc/netplan/01-netcfg.yaml`.
```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    # interface name
    ens18:
      dhcp4: false
      # IP address / subnet mask
      # removed exact numbers for security
      addresses:
        - xxx.xxx.xxx.xxx/25
      # default gateway
      routes:
        - to: default
          via: xxx.xxx.xxx.xxx
      nameservers:
        addresses:
        - 1.1.1.1
        - 8.8.8.8
        - 8.8.4.4
      dhcp6: false
```
  - Apply configuration
  ```bash
  sudo netplan --debug apply
  ```
  - Ping local IP and external IP to check
  ```bash
  ping xxx.xxx.xxx.xxx
  ping google.com
  ```
  - I like to see what is happening!
  ```bash
  ip -s link show ens18
  ip route show
  ```

## Update OS

```bash
sudo apt update
sudo apt upgrade
sudo reboot
sudo apt install vim build-essential git
```

## Purge snap

I do not like things happening in the background without my knowledge.
For me, the first thing to do after a fresh install is to remove `snap`.
```bash
sudo snap list
sudo systemctl disable snapd.service
sudo systemctl disable snapd.socket
sudo systemctl disable snapd.seeded.service
sudo snap remove --purge lxd
sudo snap remove --purge core20
sudo snap list # this must not list anything else
sudo apt remove --autoremove snapd
sudo rm -rf ~/snap /snap /var/snap /var/lib/snapd /root/snap
```
The last command complains about "read-only file system".
So, I had to reboot to stop the systemd services and rerun the command.


I manually removed snap related systemd services, following [this Stackoverflow answer](https://superuser.com/a/936976).
```bash
cd /etc/systemd/system
sudo systemctl stop snap-snapd-18357.mount
sudo systemctl disable snap-snapd-18357.mount
sudo rm -f snap-snapd-18357.mount
sudo systemctl daemon-reload
sudo systemctl reset-failed
```
I did the same thing for all these services:
```default
- snap-snapd-20092.mount
- snapd.aa-prompt-listener.service
- snapd.apparmor.service
- snapd.autoimport.service
- snapd.core-fixup.service
- snapd.seeded.service 
- snapd.snap-repair.timer
- snapd.service
- snapd.socket 
- snapd.system-shutdown.service
- snapd.recovery-chooser-trigger.service
```
**To-Do:** `snapd.seeded.service` is still being listed by `systemctl list-units -a`. How to remove?

Prevent snap from re-installing.
Create the file `/etc/apt/preferences.d/nosnap.pref` with the following content and save.
```bash
Package: snapd
Pin: release a=*
Pin-Priority: -10
```

## Add User For Tasks

user `minion`, group `minion` (not in sudoer list)
```bash
sudo groupadd minion
sudo usermod -a -G minion banskt
sudo useradd -g minion -m -c "User account for webstack" -s /bin/bash minion
sudo passwd minion
```

## SSH Security

  - Select a port to change the default SSH Port. 
  Do not choose a port already in use.
  Ports from 0 to 1023 are reserved and should not be used. Choose a port greater than 1023 and less than 65535. Check using:
  ```bash
  ss
  ss - tulpn
  ```
  - Change the following relevant lines in `/etc/ssh/sshd_config`
  ```ini
  # Change protocol
  Protocol 2
  # 
  Port xxxxx
  LogLevel VERBOSE
  PermitRootLogin no
  # trusted hosts are still considered a security risk
  HostbasedAuthentication no
  IgnoreRhosts yes
  # do not allow eavesdropping
  PermitEmptyPasswords no
  AllowTcpForwarding no
  X11Forwarding no
  # last login info can provide available users to hackers
  PrintLastLog no
  ```
  Save the file and restart SSH service.
  
  ```bash
  sudo systemctl restart ssh
  sudo systemctl status ssh
  ```
  - Open the port in firewall
  ```bash
  sudo apt install ufw
  sudo ufw app list
  sudo ufw status verbose
  sudo ufw allow xxxxx/tcp # enter the SSH port here
  sudo ufw enable
  sudo ufw status verbose
  ```
  - Set up `~/.ssh/config` and SSH key on the client side.
  - Check if SSH is working!

## Add Swap Memory

```bash
sudo -i
dd if=/dev/zero of=/swapfile bs=1024 count=1048576 #1GB: 1024 x 1024 = 1048576
chmod 0600 /swapfile
mkswap /swapfile
swapon /swapfile
echo "/swapfile none swap sw 0 0" >> /etc/fstab
swapon -s
free -m
```

## Mount Hard Disks

  - Check existing partitions and harddisks
  ```bash
  sudo lsblk
  sudo fdisk -l
  sudo lshw -C disk
  ```
  - Partition using `parted`.
  - Create entry in `etc/fstab`. You can check all uuid from `ls -lh /dev/disk/by-uuid/`
  or individually from `sudo blkid /dev/sdb1`.
  ```ini
  # /dev/sdb1 --> /opt
  /dev/disk/by-uuid/xxxx /opt ext4 defaults 0 2
  # /dev/sdb2 --> ~/local
  /dev/disk/by-uuid/xxxx /home/banskt/local ext4 user,rw,suid,dev,exec,auto,async 0 2
  # /dev/sdb3 --> ~/data
  /dev/disk/by-uuid/xxxx /home/banskt/data ext4 user,rw,suid,dev,exec,auto,async 0 2
  ```
  The sequence of options are important.
  - After mounting you have to change the ownership of the directories, if required.
  - Reboot and check if the partitions are mounted automatically.


## Bash

Install [dotfiles from Github](https://github.com/banskt/dotfiles).
But, I did not want to install everything from `.dotfiles`. 
So, I made a `dryrun` to import the functions and link individual dotfiles.
```bash
git clone https://github.com/banskt/dotfiles.git ~/.dotfiles
source ~/.dotfiles/install dryrun
DRYRUN=false
backup_and_link .bashrc bash/bashrc
backup_and_link .vimrc vim/vimrc
backup_and_link .vim vim/dotvim
cp ~/.dotfiles/git/gitconfig ~/.gitconfig
cp ~/.dotfiles/ssh/config ~/.ssh/
chmod 600 ~/.ssh/config
```
I edited the `.ssh/config` file and kept configurations for Github
and my other servers (vultr and feral).
I edited the `.gitconfig` to include my email.
Logout and login for the changes to take effect.

Finally, create SSH key for Github and add that key to the Github account!
```bash
cd ~/.ssh
ssh-keygen -t ed25519 -f github_key
git remote set-url origin git@github.com:banskt/dotfiles.git
git remote show origin
```

**Note:** Any custom bash script for this server must go to `~/.custom_dotfiles/bashrc`.
Common bash scripts go to the `~/.dotfiles`.

**To-Do:** Include a `server` flag for installation.

## Reduce Automatic Network Usage

There are some default packages or services that connects to the internet without my consent.
[AskUbuntu Question](https://askubuntu.com/q/1057458).

## Environment Modules

I love [modules](https://github.com/cea-hpc/modules) to manage my shell environment.
For a dedicated server, it may not be necessary, but it helps me to manage versions and updates.

First, install the dependencies. 
```bash
# use apt-cache search for the latest version
sudo apt install tcl8.6-dev 
# dejagnu provides runtest. Only install if you want to run `make test`, skip otherwise
# without dejagnu, configure produces this -->
## WARNING: Install `dejagnu' if you want to run the testsuite
sudo apt install dejagnu 
```
Note: I have not installed `dejagnu`.

Next, install the package.
```bash
wget github.com/cea-hpc/modules/releases/download/v5.3.1/modules-5.3.1.tar.gz
tar -zxf modules-5.3.1.tar.gz
./configure --prefix=/opt/modules --modulefilesdir=/opt/modulefiles --with-tcl-ver=8.6
make -j 2
sudo make install
```

Finally, configure. Initialize modules in `~/.custom_dotfiles/bashrc`:
```bash
# Environment modules
source /opt/modules/init/bash
```
Also, put all the example dotfiles in a separate directory:
```bash
sudo mkdir -p /opt/modules/examples
cd /opt/modulefiles
sudo mv dot module-git module-info modules null use.own /opt/modules/examples/
```

## LEMP Stack (nginx, MySQL, PHP)

Previously, I installed a [webstack in Kalindi](https://github.com/banskt/dotfiles/blob/main/docs/webstack_kalindi.md).

### Install nginx from source

Compiling nginx from source affords more flexibility than prebuilt packages: 
I can add particular modules (from nginx or third parties), and apply latest security patches.
See [official documentation](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/#sources)
for help. 

**1. Install prerequisites**.

#### PCRE2

If you want to install PCRE2 from scratch, it can be done as:
```bash
sudo apt install zlib1g-dev libbz2-dev libreadline-dev libedit-dev
wget github.com/PCRE2Project/pcre2/releases/download/pcre2-10.42/pcre2-10.42.tar.gz
tar -zxf pcre2-10.42.tar.gz
cd pcre2-10.42
./configure --prefix /opt/pcre2/10.42 --enable-unicode --enable-jit --enable-pcre2-16 --enable-pcre2-32 --enable-pcre2grep-libz --enable-pcre2grep-libbz2 --enable-pcre2test-libreadline --disable-static
make -j 2
make check
sudo make install
```
I preferred to install the library files in the OS:
```bash
sudo apt install libpcre2-dev
```
**Surprise:** `pcre3` is older than `pcre2`. Do not install `pcre3`.

#### Zlib
```bash
sudo apt install zlib1g-dev
```

#### OpenSSL
nginx requires `libssl-dev` package. But before installing anything,
I checked the distribution of current OpenSSL package:
```bash
openssl version -a
```
I have version 3.0.2 installed by default. 
I wanted the latest version and control of OpenSSL, hence I configured myself ([see documentation](https://github.com/openssl/openssl/blob/master/INSTALL.md))
using the options from [Linux from Scratch](https://www.linuxfromscratch.org/lfs/view/development/chapter08/openssl.html).
Also, run `./Configure LIST` to see a list of configuration options.
```bash
wget https://www.openssl.org/source/openssl-3.1.3.tar.gz
tar -zxf openssl-3.1.3.tar.gz
mkdir openssl-3.1.3-build
cd openssl-3.1.3-build/
../openssl-3.1.3/Configure linux-x86_64 --prefix=/opt/openssl/3.1.3/ zlib-dynamic shared
make -j 2
make test
sudo make install
```

I created a module file to load/unload the required OpenSSL version easily.
```bash
module load openssl/3.1.3
module unload openssl/3.1.3
```

**2. Install nginx**

#### Configure

Download the source files from [nginx.org](https://www.nginx.org/en/download.html).
I used the latest stable release.
```bash
wget https://nginx.org/download/nginx-1.24.0.tar.gz
tar -zxf nginx-1.24.0.tar.gz
```
There are many configuration options for nginx. I read them in the [official docs](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/#sources) and in their [open source project](https://nginx.org/en/docs/configure.html). 
Other resources include:

  - Erick T. Hitter discusses [compiling nginx with custom OpenSSL support](https://ethitter.com/2016/06/nginx-openssl-1-0-2-http-2-alpn/) -- 
  [mirror on waybackmachine](https://web.archive.org/web/20230920221352/https://ethitter.com/2016/06/nginx-openssl-1-0-2-http-2-alpn/).
  - Stackoverflow: [Can't compile nginx with SSL support, OpenSSL not found](https://serverfault.com/questions/416571)
  - nginx forum: [build nginx with OpenSSL shared library not using the system OpenSSL library 
  but using the shared library in a specific path](https://forum.nginx.org/read.php?2,275441,275447#msg-275447).

Here are the configuration options I used:
```bash
./configure --prefix=/opt/nginx/1.24.0 --builddir=../nginx-1.24.0-build --with-http_ssl_module --with-pcre --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-http_auth_request_module --with-threads --with-stream --with-stream_ssl_module --with-http_slice_module --with-mail --with-mail_ssl_module --with-file-aio --with-cc-opt="-I /opt/openssl/3.1.3/include" --with-ld-opt="-L /opt/openssl/3.1.3/lib64 -ldl -Wl,-rpath,/opt/openssl/3.1.3/lib64"
```
Here is the configuration output which may be helpful later:
```bash
Configuration summary
  + using threads
  + using system PCRE2 library
  + using system OpenSSL library
  + using system zlib library

  nginx path prefix: "/opt/nginx/1.24.0"
  nginx binary file: "/opt/nginx/1.24.0/sbin/nginx"
  nginx modules path: "/opt/nginx/1.24.0/modules"
  nginx configuration prefix: "/opt/nginx/1.24.0/conf"
  nginx configuration file: "/opt/nginx/1.24.0/conf/nginx.conf"
  nginx pid file: "/opt/nginx/1.24.0/logs/nginx.pid"
  nginx error log file: "/opt/nginx/1.24.0/logs/error.log"
  nginx http access log file: "/opt/nginx/1.24.0/logs/access.log"
  nginx http client request body temporary files: "client_body_temp"
  nginx http proxy temporary files: "proxy_temp"
  nginx http fastcgi temporary files: "fastcgi_temp"
  nginx http uwsgi temporary files: "uwsgi_temp"
  nginx http scgi temporary files: "scgi_temp"
```

#### Build
Build nginx in the new build directory.
```bash
make -f ../nginx-1.24.0-build/Makefile -j 2
sudo make -f ../nginx-1.24.0-build/Makefile install
```

**3. Post-install configuration**

I initially considered using custom ports for HTTP and HTTPS 
(instead of the default 80 and 443) but I rejected the idea
because Let's Encrypt requires port 80 for generating and renewing certificates.
These articles also helped in making the decision:

  - [Let’s Encrypt explains why you should keep port 80 open](https://letsencrypt.org/docs/allow-port-80/)
  - [Scott Helme argues against closing port 80](https://scotthelme.co.uk/why-closing-port-80-is-bad-for-security/)


#### nginx.conf

Modify the configuration file for external access.
Here is my initial nginx configuration in `/opt/nginx/1.24.0/conf/nginx.conf`.
```default
user  minion;
worker_processes  1;

events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       80;
        server_name  127.0.0.1 <ipv4_address>;
        location / {
            root   html;
            index  index.html index.htm;
        }
        # redirect server error pages to the static page /50x.html
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```
#### Open port in firewall

To register `nginx` as an `ufw` application, create a file `/etc/ufw/applications.d/nginx`.
Replace `xx` with port numbers for HTTP and HTTPS.
If you are running nginx as a non-root user, then 
you have to change the accessible port because the default port 80 
is not available to non-root users. Therefore, it's necessary to use a port > 1000. 
```ini
[Nginx HTTP]
title=Web Server (Nginx, HTTP)
description=Small, but very powerful and efficient web server
ports=80/tcp

[Nginx HTTPS]
title=Web Server (Nginx, HTTPS)
description=Small, but very powerful and efficient web server
ports=443/tcp

[Nginx Full]
title=Web Server (Nginx, HTTP + HTTPS)
description=Small, but very powerful and efficient web server
ports=80,443/tcp
```
Check the registered app and allow nginx HTTP.
```bash
sudo ufw app info 'Nginx HTTP'
sudo ufw allow 'Nginx HTTP'
```
Log files should be accessible by the user `minion`.
```bash
chown -R root:minion /opt/nginx/1.24.0/logs
chown minion:minion /opt/nginx/1.24.0/logs/access.log
chown minion:minion /opt/nginx/1.24.0/logs/error.log
chmod 775 /opt/nginx/1.24.0/logs
```

#### Useful commands
Check nginx configuration and start nginx.
```bash
# check configuration
sudo /opt/nginx/1.24.0/sbin/nginx -t
# start
sudo /opt/nginx/1.24.0/sbin/nginx
# stop
sudo /opt/nginx/1.24.0/sbin/nginx -s stop
# restart
sudo /opt/nginx/1.24.0/sbin/nginx -s reload
```

#### systemd
Create a systemd service file to control nginx using `systemctl` 
as [described in the official documentation](https://www.nginx.com/resources/wiki/start/topics/examples/systemd/).
In Ubuntu 22.04, the file is `/lib/systemd/system/nginx.service`.
```ini
[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=/opt/nginx/1.24.0/logs/nginx.pid
ExecStartPre=/opt/nginx/1.24.0/sbin/nginx -t
ExecStart=/opt/nginx/1.24.0/sbin/nginx
ExecReload=/opt/nginx/1.24.0/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```
Now, I can use `systemctl` commands to control nginx.
```bash
sudo systemctl status nginx
sudo systemctl start nginx
sudo systemctl stop nginx
sudo systemctl restart nginx
```

#### Check
Fire up the browser and check both links:

  - http://127.0.0.1
  - http://\<ipv4\_address\>

If you are installing on the server and you do not have access to the 
`localhost (127.0.0.1)` of the remote server,
then you can ssh-tunnel to the remote server from your local machine.
For example, I defined `ashwini` in `ssh/config` of the local machine and 
installed `ssh-localportfwd` from [here](https://github.com/banskt/dotfiles/blob/main/bin/ssh-localportfwd).
```bash
ssh-localportfwd open ashwini 80 <local_port>
```
Then, I can access the `localhost` of the remote machine using `http://127.0.0.1:xx`
where `xx` is the `local_port` of my local machine through which I tunneled. 
The second IPv4 address should work from external network.

The SSL connection will still not work. Do not worry yet.

#### Modular control
Once everything was working,
I removed the external IP from the base configuration of nginx
and created server configurations in `~/local/.nginx/sites-available/`
For example, here is my `000-default-server.conf`:
```default
server {
    listen      80 default_server;
    server_name <ipv4_address>;
    location / {
        root        /path/to/webdata/base;
        index       index.html index.htm;
    }
    # redirect server error pages to the static page /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root        /path/to/webdata/base;
    }

    # produce a directory listing using ngx_http_autoindex_module 
    autoindex            on;
    autoindex_exact_size off;
    autoindex_localtime  on;

    # Deny access to anything starting with .ht
    location ~ /\.ht {
        deny  all;
    }
}
```
I added the following line to `/opt/nginx/1.24.0/conf/nginx.conf`:
```default
include /home/banskt/local/.nginx/sites-enabled/*
```
And then created the `sites-enabled` directory:
```bash
mkdir -p ~/local/.nginx/sites-enabled
cd ~/local/.nginx/sites-enabled
ln -s /home/banskt/local/.nginx/sites-available/000-default-server.conf ./default
```
This way, I can manage adding domains, sub-domains, sub-directories 
on my server directly from my `sites-available` and `sites-enabled` directories.

At this point, `127.0.0.1` should serve the nginx welcome message
and `<ipv4_address>` should serve the HTML files from `/path/to/webdata/base`.
Again, check they are working with `ssh-localportfwd`.

### Link domain name

I had purchased several domain names. Now, it is time to put one of them to use.
You can skip this step and access the server using IPv4 address instead.

  - Login to [namesilo.com](https://namesilo.com)
  - Manage DNS
  - Use default nameservers of `namesilo.com`
  - Change `A` record pointing to the VPS IPv4 address.
  You can point different subdomains to different IP addresses.
  If you want to point every subdomain to the same IP, you can use an asterisk (`*`) as your subdomain.
  - Update `nginx.conf`, change IPv4 address to `mydomain.com`.

#### Alias www to non-www

I want to redirect all traffic from `www` to `non-www`.
Easiest way is to define an `A` entry for `www.mydomain.com`
and use 301 redirect from nginx configuration.
However, when my IP changes then I have to change the `A` record for 
both `mydomain.com` and `www.mydomain.com`.
Another solution is to use `CNAME` entry in the DNS zone file
and redirect in the server nginx configuration.
Both of them are required as [explained in this Stackoverflow answer](https://serverfault.com/a/661562).

> A CNAME record does not function the same way as a URL redirect.
> A CNAME record directs web traffic for a particular domain
> to the target domain’s IP address.
> Once the visitor reaches that IP address,
> the web server’s configuration will determine how the domain is handled.
> If that domain is not configured on the server, 
> the server will simply display its default web page (if any).
> This may or may not be the web page for the 
> target domain in the CNAME record,
> depending on how the server is configured.

  - Add `CNAME` entry in zonefile.
  - Add 301 redirect in `nginx.conf`
```default
server {
    listen      80;
    server_name www.mydomain.com;
    return 301 $scheme://mydomain.com$request_uri;
}
```

#### Check DNS

There are many DNS lookups, but I like [intoDNS](https://intodns.com).

### SSL

I did not use `certbot` because it enforced installation using `snap`.

  - Install [acme](https://github.com/acmesh-official/acme.sh).
  The options used for the installation are explained in the 
  [documentation](https://github.com/acmesh-official/acme.sh/wiki/How-to-install#4-advanced-installation).
  ```bash
  git clone https://github.com/acmesh-official/acme.sh.git
  cd acme.sh/
  ./acme.sh --install --home /home/banskt/local/.acme --accountemail banskt.saikat@gmail.com
  ```
  Delete the entry in `~/.bashrc` and add it to `~/.custom_dotfiles/bashrc`.

  ```bash
  # Source acme.sh for SSL certificates
  source "/home/banskt/local/.acme/acme.sh.env"
  ```
  After sourcing, `acme.sh` will be available on commandline. Check.

  - Create the acme-challenge directory in the document root.
  ```bash
  cd /path/to/webdata/base
  mkdir -p .well-known/acme-challenge/
  sudo chown -R minion:minion .well-known
  sudo chmod -R 770 .well-known
  ```
  and give permissions according to your setup.

  - Create directory to store SSL certificates
  ```bash
  cd /home/banskt/local/.nginx/
  mkdir -p ssl/mydomain.com/
  ```

  - Generate dhparams file
  ```bash
  cd /home/banskt/local/.nginx/ssl/
  module load openssl/3.1.3
  openssl dhparam -out dhparams.pem 4096
  ```

  - Issue certificates. Optionally,
  use [DNS API](https://github.com/acmesh-official/acme.sh/wiki/dnsapi).
  You can either issue certificate for a single domain,
  ```bash
  acme.sh --issue -d foo.mydomain.com -w /path/to/webdata/base -k 4096
  ```
  or have multiple domains in the same certificate.

  ```bash
  acme.sh --issue -d mydomain.com -d www.mydomain.com -w /path/to/webdata/base -k 4096
  ```
  Here, `-w` specifies the document root of the website where the acme-challenge is created,
  `-k` specifies the domain key length.

  - Generate SSL configurations from 
  [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org).
  Write the configuration in `/opt/nginx/1.24.0/conf/ssl_params.conf`
  so that it can be included for all servers.
  For each server, create the SSL nginx configuration, for example,
  ```default
    ssl_certificate         /home/banskt/local/.nginx/ssl/sbanerjee.in/fullchain.pem;
    ssl_certificate_key     /home/banskt/local/.nginx/ssl/sbanerjee.in/privkey.pem;
    # verify chain of trust of OCSP response using Root CA and Intermediate certs
    ssl_trusted_certificate /home/banskt/local/.nginx/ssl/sbanerjee.in/fullchain.pem;
    include                 /opt/nginx/1.24.0/conf/ssl_params.conf;
  ```

  - Install the issued certificate to nginx server
  ```bash
  acme.sh --install-cert -d mydomain.com \
    --fullchain-file /home/banskt/local/.nginx/ssl/mydomain.com/fullchain.pem \
    --key-file /home/banskt/local/.nginx/ssl/mydomain.com/privkey.pem \
    --reloadcmd "sudo systemctl restart nginx"
  acme.sh --install-cert -d foo.mydomain.com \
    --fullchain-file /home/banskt/local/.nginx/ssl/foo.mydomain.com/fullchain.pem \
    --key-file /home/banskt/local/.nginx/ssl/foo.mydomain.com/privkey.pem \
    --reloadcmd "sudo systemctl restart nginx"
  ```

  - Check everything is working! Use browser and 
  [Qualys SSL server test](https://www.ssllabs.com/ssltest/).
  ```
  acme.sh --help
  acme.sh --list
  ```

### Improve speed and performance

  - [Tuning nginx can improve speed and performance](https://github.com/denji/nginx-tuning).
  - [Better SSL configuration](https://scaron.info/blog/improve-your-nginx-ssl-configuration.html)
  - [Let's Encrypt without port 80](https://jmorahan.net/articles/lets-encrypt-without-port-80)
